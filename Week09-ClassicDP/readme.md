## 10130 - SuperSale
[Problem](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=1071)\
This problem is a variation of a knapsack problem - each person can only take one item for the "special price", and given a family member consisting of `G` members and each member can carry at most `MW` (differs each person, can be same though), find the "worth", or the sum of the low-price that the whole family can buy, given the weight limit of each member. In other words, every member is a knapsack, and we need to find the worth of each knapsack and total it as the final answer.
  
Rather than recalculating each family member, it is known that the maximum weight is 30, so we can build the dp table in bottom-up fashion, so that finding the maximum weight can be performed in constant time. To fill the dp table, I used a nested for loop. The first depth is to iterate through each object. The second is for the weight, from 30 to 0. If the current weight (j) can fit the current object (i), then we should find the maximum value between the current value in the dp table, and the sum of the current object's worth and the maximum possible for the remaining weight (we assume that the value in the dp table contains the maximum worth for that current weight). For example, given a member that can carry up to 30, and we have an object with weight 20, the maximum worth for weight 30 would be the object's worth + the maximum worth given weight 30-20, or the current dp table itself. In other words, `dpTable[30] = maximum value between dpTable[30] and objectPrice[i] + dpTable[30-20]`.
  
Complexity would be O(**TNW**), where T is the amount of test cases, N is the amount of objects, and W is the maximum weight possible.
  
I tried my best to explain this but it is quite hard to explain the witchcraft called `DYNAMIC PROGRAMMING`.
![Verdict](https://raw.githubusercontent.com/AAlab1819/SebastianAldi-01082170015/master/Week09-ClassicDP/Verdict.JPG)
